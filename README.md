# Device Management API

A comprehensive REST API for managing device resources with full CRUD operations, built with Spring Boot 3 and Java 21.

## üìã Table of Contents

- [Features](#features)
- [Tech Stack](#tech-stack)
- [Prerequisites](#prerequisites)
- [Quick Start](#quick-start)
- [API Documentation](#api-documentation)
- [Database Schema](#database-schema)
- [Business Rules](#business-rules)
- [Testing](#testing)
- [Docker Deployment](#docker-deployment)
- [Development](#development)
- [Future Improvements](#future-improvements)

## ‚ú® Features

- **Complete CRUD Operations**: Create, Read, Update, and Delete devices
- **Advanced Filtering**: Filter devices by brand, state, or both
- **State Management**: Track device availability (available, in-use, inactive)
- **Business Rule Validation**: Enforce constraints on updates and deletions
- **Comprehensive API Documentation**: Interactive Swagger UI
- **Containerized Deployment**: Docker and Docker Compose support
- **Robust Testing**: Unit and integration tests with high coverage
- **Global Exception Handling**: Consistent error responses
- **Database Persistence**: PostgreSQL for production, H2 for testing

## üõ† Tech Stack

- **Java 21** - Latest LTS version with modern features
- **Spring Boot 3.5.0** - Framework for building production-ready applications
- **Spring Data JPA** - Data access layer with Hibernate
- **PostgreSQL** - Production database
- **H2 Database** - In-memory database for testing
- **Maven 3.9+** - Dependency management and build tool
- **Docker & Docker Compose** - Containerization
- **Swagger/OpenAPI 3** - API documentation
- **JUnit 5** - Testing framework

## üìã Prerequisites

- Java 21 or higher
- Maven 3.9+ or Gradle 8+
- Docker and Docker Compose (for containerized deployment)
- PostgreSQL (if running locally without Docker)

## üöÄ Quick Start

### Using Docker (Recommended)

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd device-management-api
   ```

2. **Start the application with Docker Compose**
   ```bash
   docker-compose up --build
   ```

3. **Access the application**
    - API Base URL: `http://localhost:8080/api/devices`
    - Swagger UI: `http://localhost:8080/swagger-ui.html`
    - API Docs: `http://localhost:8080/api-docs`

### Local Development

1. **Setup PostgreSQL Database**
   ```sql
   CREATE DATABASE devicedb;
   CREATE USER postgres WITH PASSWORD 'postgres';
   GRANT ALL PRIVILEGES ON DATABASE devicedb TO postgres;
   ```

2. **Run the application**
   ```bash
   ./mvnw spring-boot:run
   ```

3. **Run tests**
   ```bash
   ./mvnw test
   ```

## üìñ API Documentation

### Base URL
```
http://localhost:8080/api/devices
```

### Endpoints

| Method | Endpoint | Description | Request Body |
|--------|----------|-------------|--------------|
| POST | `/api/devices` | Create a new device | DeviceCreateDto |
| GET | `/api/devices` | Get all devices | - |
| GET | `/api/devices?brand={brand}` | Get devices by brand | - |
| GET | `/api/devices?state={state}` | Get devices by state | - |
| GET | `/api/devices/{id}` | Get device by ID | - |
| PUT | `/api/devices/{id}` | Fully update device | DeviceUpdateDto |
| PATCH | `/api/devices/{id}` | Partially update device | DeviceUpdateDto |
| DELETE | `/api/devices/{id}` | Delete device | - |

### Request/Response Examples

#### Create Device
```bash
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{
    "name": "iPhone 15 Pro",
    "brand": "Apple"
  }'
```

#### Response
```json
{
  "id": 1,
  "name": "iPhone 15 Pro",
  "brand": "Apple",
  "state": "AVAILABLE",
  "creationTime": "2024-06-01T10:30:00"
}
```

#### Update Device State
```bash
curl -X PATCH http://localhost:8080/api/devices/1 \
  -H "Content-Type: application/json" \
  -d '{
    "state": "IN_USE"
  }'
```

#### Filter Devices
```bash
# By brand
curl "http://localhost:8080/api/devices?brand=Apple"

# By state
curl "http://localhost:8080/api/devices?state=available"

# By both brand and state
curl "http://localhost:8080/api/devices?brand=Apple&state=in-use"
```

### Device States

- `AVAILABLE` - Device is available for use
- `IN_USE` - Device is currently being used
- `INACTIVE` - Device is inactive/offline

## üóÑ Database Schema

```sql
create table device
(
    id            bigint generated by default as identity primary key,
    brand         varchar(255) not null,
    creation_time timestamp(6),
    name          varchar(255) not null,
    state         varchar(255) not null
        constraint device_state_check
            check ((state)::text = ANY
                   ((ARRAY ['AVAILABLE'::character varying,
                       'IN_USE'::character varying,
                       'INACTIVE'::character varying])::text[])),
    update_time   timestamp(6),
    version       bigint
);
```

## üìã Business Rules

### Validation Rules

1. **Creation Time**: Cannot be updated after device creation
2. **Name and Brand**: Cannot be updated if device is in `IN_USE` state
3. **Deletion**: Devices in `IN_USE` state cannot be deleted
4. **Required Fields**: Name and brand are mandatory during creation

### Error Handling

The API provides comprehensive error handling with appropriate HTTP status codes:

- `400 Bad Request` - Validation errors or business rule violations
- `404 Not Found` - Device not found
- `500 Internal Server Error` - Unexpected server errors

Example error response:
```json
{
  "status": 400,
  "message": "Cannot update name or brand of a device that is in use",
  "timestamp": "2024-06-01T10:30:00"
}
```

## üß™ Testing

### Running Tests

```bash
# Run all tests
./mvnw test

# Run only unit tests
./mvnw test -Dtest="*Test"

# Run only integration tests
./mvnw test -Dtest="*IT"
```

### Test Coverage

The project includes comprehensive test coverage:

- **Unit Tests**: Service layer business logic
- **Integration Tests**: Controller endpoints
- **Repository Tests**: Data access layer
- **Validation Tests**: Input validation and business rules

### Test Profiles

- **Test Profile**: Uses H2 in-memory database
- **Dev Profile**: Uses PostgreSQL database

## üê≥ Docker Deployment

### Docker Compose (Production-ready)

```bash
# Build and start all services
docker-compose up --build

# Run in detached mode
docker-compose up -d

# Stop services
docker-compose down

# View logs
docker-compose logs -f device-api
```

### Individual Docker Commands

```bash
# Build the application image
docker build -t device-management-api .

# Run PostgreSQL container
docker run -d \
  --name postgres-db \
  -e POSTGRES_DB=devicedb \
  -e POSTGRES_USER=deviceuser \
  -e POSTGRES_PASSWORD=devicepass \
  -p 5432:5432 \
  postgres:15-alpine

# Run the application container
docker run -d \
  --name device-api \
  --link postgres-db:postgres \
  -e SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/devicedb \
  -p 8080:8080 \
  device-management-api
```

## üíª Development

### Project Structure

```
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îú‚îÄ‚îÄ java/com/deviceapi/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controller/          # REST controllers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/             # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository/          # Data access layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entity/              # Entity classes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/                 # Data Transfer Objects
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/           # Custom exceptions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mapper/              # Mapper
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îú‚îÄ‚îÄ application.yml      # Configuration
‚îÇ       ‚îî‚îÄ‚îÄ static/              # Static resources
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ java/com/deviceapi/      # Test classes
```

### Configuration

The application supports multiple profiles:

- `dev` (default): Development with PostgreSQL
- `test`: Testing with H2 database
- `prod`: Production configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `DB_USERNAME` | Database username | `deviceuser` |
| `DB_PASSWORD` | Database password | `devicepass` |
| `SERVER_PORT` | Application port | `8080` |
| `ACTIVE_PROFILE` | Spring profile | `dev` |

### Adding New Features

1. **Create Entity**: Add new JPA entity in `model` package
2. **Create Repository**: Extend JpaRepository in `repository` package
3. **Implement Service**: Add business logic in `service` package
4. **Create Controller**: Add REST endpoints in `controller` package
5. **Add Tests**: Create comprehensive tests for all layers
6. **Update Documentation**: Update this README and API docs

## üîÆ Future Improvements

### Technical Enhancements

- **Authentication & Authorization**: JWT-based security
- **Rate Limiting**: API rate limiting and throttling
- **Caching**: Redis cache for frequently accessed data
- **Monitoring**: Application metrics with Micrometer and Prometheus
- **Logging**: Structured logging with ELK stack integration
- **Database Migration**: Flyway for database versioning

### Feature Enhancements

- **Device Categories**: Categorize devices by type
- **User Management**: Track device assignments to users
- **Audit Trail**: Track all device changes with timestamps
- **Bulk Operations**: Batch create/update/delete operations
- **Advanced Search**: Full-text search capabilities
- **Notifications**: Email/SMS notifications for state changes
- **Reporting**: Generate device usage reports

### Performance Optimizations

- **Database Indexing**: Optimize query performance
- **Connection Pooling**: Configure HikariCP for better performance
- **Pagination**: Implement pagination for large datasets
- **Async Processing**: Background jobs for heavy operations

### DevOps Improvements

- **CI/CD Pipeline**: GitHub Actions or Jenkins integration
- **Kubernetes Deployment**: Helm charts for Kubernetes
- **Health Checks**: Advanced health monitoring endpoints
- **Configuration Management**: External configuration with ConfigMap
- **Secrets Management**: Secure secret handling with Vault
